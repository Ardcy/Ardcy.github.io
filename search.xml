<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.29  Educational Codeforces Round 81</title>
    <url>/2021/09/24/blog2/</url>
    <content><![CDATA[<h3 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A Display The Number"></a>A <a href="https://codeforces.com/contest/1295/problem/A">Display The Number</a></h3><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>数字屏上0-9数字点亮分别需要不同的段、给定一定段，问能够点亮的最大的数字是几</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>对于偶数段 ，则最大数字的每一位都是1就可以，对于奇数段，令第一位数字是7，之后全都是1即可</p>
<h3 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B Infinite Prefixes"></a>B <a href="https://codeforces.com/contest/1295/problem/B">Infinite Prefixes</a></h3><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>有一个长度为n的01串，可以无限次叠加，定义一个前缀01差：前$i$项中0比1多的个数，问有多少个前缀01差等于$m$</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>每一个串存在一个$u​$,即整串的前缀01差，无限前缀能组成的数字仅有前$n​$项前缀01差及无限u的叠加</p>
<p>（注意考虑特殊条件） <del>不考虑就hack</del></p>
<h3 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C Obtain The String"></a>C <a href="https://codeforces.com/contest/1295/problem/C">Obtain The String</a></h3><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>有两个小写字母字符串$s$和$t$,定义操作：每次可将s的一个非连续子串取出，求最小的操作数$n$,可使得$n$次得到的子串连续成为字符串$t$</p>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>直接贪心，利用子序列自动机加速</p>
<p>将26个字母保存1个$nex$二维数组，$nex_{ij}$表示第$s$在第$i$个位置后的字母$j $第一次出现的位置,我们在求解过程中：</p>
<p>首先查找t的第一个字母在s中第一次出现的位置，即$nex_{0,t_1}$,找到第一个字母后，寻找t的第二个字母的过程就是在$s$中$t$的第一个字母的位置后继续寻找第一次出现第二个字母的位置，以此类推，若是找不到，则操作数++，重新寻找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>],t[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">100005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),m=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)nxt[n][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)nxt[i][j]=nxt[i+<span class="number">1</span>][j];</span><br><span class="line">            nxt[i][s[i+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>,ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            now=nxt[now][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(!now)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                now=nxt[now][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!now)&#123;ans=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="D-Same-GCDs"><a href="#D-Same-GCDs" class="headerlink" title="D Same GCDs"></a>D <a href="https://codeforces.com/contest/1295/problem/D">Same GCDs</a></h3><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定$a,m$,计算$\sum\limits_{i = 0}^{m - 1} {[\gcd (a,m) =  = \gcd (a + i,m)]} $</p>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>$gcd (a,m) = d \to \gcd (\frac{a}{d},\frac{m}{d}) = 1$</p>
<p>则原式可化为</p>
<p>…</p>
<p>直接求欧拉函数即可</p>
<h3 id="E-Permutation-Separation"><a href="#E-Permutation-Separation" class="headerlink" title="E Permutation Separation"></a>E <a href="https://codeforces.com/contest/1295/problem/E">Permutation Separation</a></h3><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给一个排列，每个排列中的第$i$个数字为$p_i$,权值为$w_i$.你可以选择一个位置切一刀把它分成左右两部分，然后你可以花费$w_i$把$p_i$移动到另一个部分。最终要保证左半部分的最大值小于右半部分的最小值。</p>
<h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><p>基础还是太弱，看了半天题解感觉终于明白了</p>
<p>首先暴力解法：就是枚举将左右集合分开的位置，然后枚举边界x,使得左边集合大于x的数与右边集合小于x的数花费和最小</p>
<p>线段树解法：</p>
<p>线段树是将枚举的边界x作为叶子节点的</p>
<p>如果能够确定切的位置  左边集合与右边集合均已经确定，每一个叶子节点x保存的是当前集合下以x为边界所需花费，由于线段树维护的是最小值，全局最小值就是当前确定集合的最小花费。</p>
<p>如何更新：</p>
<p>当集合发生改变时，比如说左边集合中新增了右边集合的$y$,权值为$w$,则当前集合下的最优解法中的以比y小的边界均需要将y移动到右边,区间增加$w$，比y大的边界则会略去这一步骤，即区间减去$w$</p>
]]></content>
  </entry>
  <entry>
    <title>ACM--概率</title>
    <url>/2021/09/24/blog1/</url>
    <content><![CDATA[<h4 id="n个球放入m个盒子问题"><a href="#n个球放入m个盒子问题" class="headerlink" title="n个球放入m个盒子问题"></a>n个球放入m个盒子问题</h4><ol>
<li><p>球相同，盒子不同，没有空盒子 n&gt;=m</p>
<p>插板法， C（n-1,m-1)</p>
</li>
<li><p>球相同，盒子不同，可以有空盒子</p>
<p>假设每个盒子已经有一个球，插板法 C（n+m-1,m-1)</p>
</li>
<li><p>球不同，盒子相同，没有空盒子</p>
<p> dp[n][m] = m * dp[n-1][m] + dp[n-1][m-1] 1 &lt;= m &lt; n</p>
<p>第二类斯特林数</p>
</li>
<li><p>球不同，盒子相同，可以有空盒子</p>
<p>第三种情况 枚举箱子的个数</p>
</li>
<li><p>球不同，盒子不同，没有空箱</p>
<p>dp[n][m] * fac[m]</p>
<p>dp[n][m] 指第三种情况， 因为球是不同的，盒子是相同的，给盒子定义顺序就好了</p>
</li>
<li><p>球不同，盒子不同，允许空箱，</p>
<p>m的n次方</p>
</li>
<li><p>球相同，盒子相同，允许空箱。</p>
<p>dp[n][m] = dp[n][m-1] + dp[n-m][m] n&gt;=m</p>
<p>dp[n][m] = dp[n][m-1]  n &lt; m</p>
<p>dp[k][1] = 1, dp[1][k] = 1,dp[0][k] = 1;</p>
</li>
<li><p>球相同，盒子相同，没有空箱子</p>
<p>dp[n-m][m],dp同第7种情况， n&gt;=m</p>
<p>0 n &lt; m</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>通货膨胀杂谈</title>
    <url>/2021/09/24/blog3/</url>
    <content><![CDATA[<p>​    </p>
<p>先来考虑一个基本的问题，什么是通货膨胀？如何定义通货膨胀？由此可以延伸出很多新的问题。</p>
<p>通货膨胀，是指经济运行中出现的全面、持续的物价上涨的现象。纸币发行量超过流通中实际需要的货币量，是导致通货膨胀的主要原因之一；通货紧缩，是与通货膨胀相反的一种经济现象。它表现为物价全面持续下跌，通常伴随着经济衰退出现。 </p>
<ul>
<li><p>个人理解</p>
<p>通货膨胀是货币量发行过多，导致商品价格全面上涨的现象。</p>
<p>可以由此思考哪些问题 ？ </p>
<ul>
<li>问题1： 货币量是否每一年都会发行 ？</li>
<li>问题2： 货币量 流通 和 不流通 的影响有多少 ？</li>
<li>问题3： 业主如何根据定商品价格？（是源于货币发行量过多么？</li>
<li>问题4： 通货膨胀 会导致 不同的商品 涨价，那么这个幅度会共同涨比例类似的价格？还是会出现混乱的局面？</li>
<li>GDP 增长，不发行货币 是不是就不会 出现通货膨胀的 局面 ？</li>
<li>各个国家相互之间的货币会发生怎样的影响 ？</li>
</ul>
</li>
</ul>
<h4 id="消费者物价指数是什么？"><a href="#消费者物价指数是什么？" class="headerlink" title="消费者物价指数是什么？"></a>消费者物价指数是什么？</h4><p>消费者物价指数(Consumer Price Index)，英文缩写为CPI，是反映与居民生活有关的商品及劳务价格统计出来的物价变动指标，通常作为观察通货膨胀水平的重要指标。</p>
<blockquote>
<p>如果消费者物价指数升幅过大，表明通胀已经成为经济不稳定因素，央行会有紧缩货币政策和财政政策的风险，从而造成经济前景不明朗。因此，该指数过高的升幅往往不被市场欢迎。例如，在过去12个月，消费者物价指数上升2.3％，那表示，生活成本比12个月前平均上升2.3％。当生活成本提高，你的金钱价值便随之下降。也就是说，一年前收到的一张100元纸币，今日只可以买到价值97.75元的商品或服务。一般说来当CPI&gt;3%的增幅时我们称为Inflation，就是通货膨胀；而当CPI&gt;5%的增幅时，我们把它称为Serious Inflation，就是严重的通货膨胀。 </p>
</blockquote>
<h4 id="CPI-是如何计算的？"><a href="#CPI-是如何计算的？" class="headerlink" title="CPI 是如何计算的？"></a>CPI 是如何计算的？</h4><p>消费者价格指数(Consumer Price Index)，是对一个固定的消费品篮子价格的衡量，主要反映消费者支付商品和劳务的价格变化情况，也是一种度量通货膨胀水平的工具，以百分比变化为表达形式。在美国构成该指标的主要商品共分七大类，其中包括：食品、酒和饮品住宅；衣着；交通；医药健康；娱乐；其他商品及服务。在美国，消费物价指数由劳工统计局每月公布，有两种不同的消费物价指数。一是工人和职员的消费物价指数，简称CPI-W。二是城市消费者的消费物价指数，简称CPI-U。  </p>
<h4 id="参考指标"><a href="#参考指标" class="headerlink" title="参考指标"></a>参考指标</h4><p>（CPI）是一个滞后性的数据，但它往往是市场经济活动与政府货币政策的一个重要参考指标。CPI稳定、就业充分及GDP增长往往是最重要的社会经济目标。不过，从中国的现实情况来看，CPI的稳定及其重要性并不像发达国家所认为的那样“有一定的权威性，市场的经济活动会根据CPI的变化来调整”。近几年来欧美国家GDP增长一直在2%左右波动，CPI也同样在0%～3%的范围内变化，而中国的情况则完全不同。首先是国内经济快速增长，近两年来GDP增长都在9%以上，CPI却没有多少波动，表面看来这可以说得上是“政府对经济运行调控自如，市场行为反映十分理性”。二是一年之内CPI大起大落，前后相差几个百分点；一般情况下，除非经济生活中有重大的突发事件（如1997年的亚洲金融危机），CPI是不可能大起大落的，所以2004年中国的CPI大幅波动有些异常。三是随着CPI大幅波动，国内经济一时间通货膨胀率过高，民众储蓄负利率严重，一时间居民储蓄又告别负收益，通货紧缩阴影重现。这样一种经济环境令人担忧，因此，如何理解CPI指数便成为一个十分重要的问题。  </p>
<h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>CPI的计算公式是 CPI=（一组固定商品按当期价格计算的价值）除以（一组固定商品按基期期价格计算的价值）乘以100。 CPI告诉人们的是，对普通家庭的支出来说，购买具有代表性的一组商品，在今天要比过去某一时间多花费多少，例如，若1995年某国普通家庭每个月购买一组商品的费用为800元，而2000年购买这一组商品的费用为1000元，那么该国2000年的消费价格指数为（以1995年为基期）CPI= 1000/800<em>100=125，也就是说上涨了25%。在日常中我们更关心的是通货膨胀率，它被定义为从一个时期到另一个时期价格水平变动的百分比，公式为T=（P1—P0）/P0，式子中T为1时期的通货膨胀率，P1和P0分别表示1时期和0时期的价格水平。如果用上面介绍的消费价格指数来衡量价格水平，则通货膨胀率就是不同时期的消费价格指数变动的百分比。假如一个经济体的消费价格指数从去年的100增加到今年的112，那么这一时期的通货膨胀率就为 T=（112—100）/100</em>100%=12%，就是说通货膨胀率为12%，表现为物价上涨12%。  </p>
<h5 id="货币是否每一年都会发行？"><a href="#货币是否每一年都会发行？" class="headerlink" title="货币是否每一年都会发行？"></a>货币是否每一年都会发行？</h5>]]></content>
  </entry>
</search>

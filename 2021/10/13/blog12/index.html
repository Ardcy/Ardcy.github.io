
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计算机操作系统学习笔记（二） - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="计算机操作系统第二章 进程管理考纲内容：

进程与线程
进程的概念：进程的状态与转换
进程控制：进程组织
进程通信；线程概念和多线程模型


处理机调度
调度的基本概念；调度时机、切换与过程
调度的,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    
<div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">计算机操作系统学习笔记（二）</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">计算机操作系统学习笔记（二）</h1>
        <div class="stuff">
            <span>十月 13, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p>考纲内容：</p>
<ol>
<li>进程与线程<ul>
<li>进程的概念：进程的状态与转换</li>
<li>进程控制：进程组织</li>
<li>进程通信；线程概念和多线程模型</li>
</ul>
</li>
<li>处理机调度<ul>
<li>调度的基本概念；调度时机、切换与过程</li>
<li>调度的基本准则；调度方式；典型调度算法</li>
</ul>
</li>
<li>进程同步<ul>
<li>实现进程同步的基本概念</li>
<li>实现临界区互斥的基本方法</li>
<li>信号量；管程；经典同步问题</li>
</ul>
</li>
<li>死锁<ul>
<li>死锁的概念；死锁处理策略</li>
<li>死锁预防；死锁避免；死锁的检测和解除</li>
</ul>
</li>
</ol>
<h3 id="2-1-1-进程的概念和特征"><a href="#2-1-1-进程的概念和特征" class="headerlink" title="2.1.1 进程的概念和特征"></a>2.1.1 进程的概念和特征</h3><h4 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h4><p>为了参与并发执行的程序（含数据）能够独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。由程序段、相关数据段、和PCB三部分构成了进程映像（进程实体）。</p>
<p>PCB是进程存在的唯一标志。</p>
<p>定义：</p>
<ul>
<li>进程是程序的一次执行过程</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ul>
<h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2. 进程的特征"></a>2. 进程的特征</h4><p>进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p>
<ul>
<li><p>动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p>
</li>
<li><p>并发性。</p>
<p>指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</p>
</li>
<li><p>独立性。</p>
</li>
<li><p>异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</p>
</li>
<li><p>结构性。</p>
</li>
</ul>
<h3 id="2-1-2-进程的状态与转化"><a href="#2-1-2-进程的状态与转化" class="headerlink" title="2.1.2 进程的状态与转化"></a>2.1.2 进程的状态与转化</h3><pre><code>通常进程有5种状态，前三种是基本状态。
</code></pre>
<ul>
<li>运行态。进程正在处理机上运行。在单机处理机环境下，每个时刻最多只有一个进程处于运行态。</li>
<li>就绪态。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，称为就绪队列。</li>
<li>阻塞态。进程正在等待某一资源而暂停运行。即使处理机空闲，该进程也不能运行。</li>
<li>创建态。进程正在被创建，尚未转到就绪态。</li>
<li>结束态。</li>
</ul>
<p>转换过程。</p>
<ul>
<li>就绪态-&gt;运行态：处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程就由就绪态转为运行态。</li>
<li>运行态-&gt;就绪态：处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转为就绪态</li>
<li>运行态-&gt;阻塞态</li>
<li>阻塞态-&gt;就绪态</li>
</ul>
<h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h3><h4 id="1-进程的创建"><a href="#1-进程的创建" class="headerlink" title="1. 进程的创建"></a>1. 进程的创建</h4><p>操作系统创建一个新进程的过程如下：（创建原语）</p>
<ul>
<li>为新进程分配一个唯一的进程标识号，并申请一个空白的PCB.</li>
<li>为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（在PCB中体现）。注意，若资源不足，则并不是创建失败，而是处于阻塞态，等待内存资源。</li>
<li>初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li>
<li>进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li>
</ul>
<h4 id="2-进程的终止"><a href="#2-进程的终止" class="headerlink" title="2. 进程的终止"></a>2. 进程的终止</h4><p>引起进程终止的事件主要有：1. 正常结束 2. 异常结束 3. 外界干预</p>
<p>操作系统终止进程的过程如下（撤销原语）：</p>
<ol>
<li>根据被终止的标识符，检索PCB，从中读出该进程的状态。</li>
<li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li>
<li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li>
<li>将该进程所拥有的全部资源，或归还给父进程，或归还给操作系统。</li>
<li>将该PCB从所在队列（链表）中删除。</li>
</ol>
<h4 id="3-进程的阻塞和唤醒"><a href="#3-进程的阻塞和唤醒" class="headerlink" title="3. 进程的阻塞和唤醒"></a>3. 进程的阻塞和唤醒</h4><p>系统自动执行阻塞原语。</p>
<p>阻塞原语的执行过程如下：Block原语</p>
<ol>
<li>找到将要被阻塞进程的标识号对应的PCB。</li>
<li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li>
<li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</li>
</ol>
<p>唤醒原语的执行过程如下：WakeUP原语</p>
<ol>
<li>在该事件的等待队列中找到对应进程的PCB。</li>
<li>将其从等待队列中移出，并置其状态为就绪态。</li>
<li>把该PCB插入就绪队列，等待调度程序调度。</li>
</ol>
<h4 id="4-进程切换"><a href="#4-进程切换" class="headerlink" title="4. 进程切换"></a>4. 进程切换</h4><p>进程切换的过程如下：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理机上下文。</li>
</ol>
<h3 id="2-1-4-进程的组织"><a href="#2-1-4-进程的组织" class="headerlink" title="2.1.4 进程的组织"></a>2.1.4 进程的组织</h3><ul>
<li><p>进程控制块</p>
<p>进程创建时，操作系统新建一个PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。</p>
<p>为了方便进程的调度和管理，需要将各进程的PCB用适当的方式组织起来。目前，常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接程一个队列，不同状态对应不同的队列。同时建立索引表。</p>
</li>
<li><p>程序段</p>
<p>就是能被进程调度程序调度到CPU执行的程序代码段。</p>
</li>
<li><p>数据段</p>
</li>
</ul>
<h3 id="2-1-5-进程的通信"><a href="#2-1-5-进程的通信" class="headerlink" title="2.1.5 进程的通信"></a>2.1.5 进程的通信</h3><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。</p>
<h4 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1. 共享存储"></a>1. 共享存储</h4><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具。</p>
<h4 id="2-消息传递"><a href="#2-消息传递" class="headerlink" title="2. 消息传递"></a>2. 消息传递</h4><ul>
<li>直接通信方式</li>
<li>间接通信方式</li>
</ul>
<h4 id="3-管道通信"><a href="#3-管道通信" class="headerlink" title="3. 管道通信"></a>3. 管道通信</h4><h3 id="2-1-6-线程概念和多线程模型"><a href="#2-1-6-线程概念和多线程模型" class="headerlink" title="2.1.6 线程概念和多线程模型"></a>2.1.6 线程概念和多线程模型</h3><p>引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的是为了减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<h4 id="1-线程的基本概念"><a href="#1-线程的基本概念" class="headerlink" title="1. 线程的基本概念"></a>1. 线程的基本概念</h4><p>线程最直接的理解就是“轻量级进程”，它时一个基本的CPU执行单元，也是程序执行流的最小单元，有线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不再拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中出现间断性。线程也有就绪、阻塞和运行三种基本状态。</p>
<p>若线程的切换发生在同一个进程内部，则只需要很少的时空开销。</p>
<h4 id="2-线程与进程的比较"><a href="#2-线程与进程的比较" class="headerlink" title="2. 线程与进程的比较"></a>2. 线程与进程的比较</h4><ol>
<li><p>调度</p>
</li>
<li><p>拥有资源</p>
</li>
<li><p>并发性</p>
</li>
<li><p>系统开销</p>
</li>
<li><p>地址空间和其他资源</p>
</li>
<li><p>通信方面</p>
</li>
</ol>
<h4 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h4><p>线程的主要属性如下：</p>
<ol>
<li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li>
<li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li>
<li>同一进程中的各个线程共享该进程所拥有的资源。</li>
<li>线程是处理机的独立调度单位，多个线程是可以并发执行的。</li>
<li>一个线程被创建后就开始了它的生命周期，直至终止。</li>
</ol>
<h4 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h4><p>线程的实现可以分为两类：用户级线程和内核级线程。</p>
<h4 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h4><ol>
<li><p>多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（透明）。</p>
<p>优点：线程管理是在用户空间进行的，因而效率比较高。</p>
<p>缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</p>
</li>
<li><p>一对一模型。将每个用户级线程映射到一个内核级线程。</p>
<p>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力强。</p>
<p>缺点：每创建一个用户级线程都需要创建一个内核级线程与之对应，开销比较大。</p>
</li>
<li><p>多对多模型。集二者之长。</p>
</li>
</ol>
<h2 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h2><h3 id="2-2-1-调度的概念"><a href="#2-2-1-调度的概念" class="headerlink" title="2.2.1 调度的概念"></a>2.2.1 调度的概念</h3><h4 id="1-调度的基本概念"><a href="#1-调度的基本概念" class="headerlink" title="1. 调度的基本概念"></a>1. 调度的基本概念</h4><p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平，高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<p>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p>
<h4 id="2-调度的层次"><a href="#2-调度的层次" class="headerlink" title="2. 调度的层次"></a>2. 调度的层次</h4><p>作业从提交到完成，要经历三级调度。</p>
<ol>
<li>作业调度。又称高级调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它们分配内存、输入/输出设备等等资源，并建立相应的进程，以使它们获得竞争处理机的权利。简而言之，作业调度就是内存与辅存之间的调度。对于每个作业只调入一次，调出一次。</li>
<li>中级调度。又称是内存调度，其作用是提高内存利用率和系统吞吐量。</li>
<li>进程调度。又称低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ol>
<h4 id="3-三级调度之间的关系"><a href="#3-三级调度之间的关系" class="headerlink" title="3. 三级调度之间的关系"></a>3. 三级调度之间的关系</h4><h3 id="2-2-2-调度的时机，切换与过程"><a href="#2-2-2-调度的时机，切换与过程" class="headerlink" title="2.2.2 调度的时机，切换与过程"></a>2.2.2 调度的时机，切换与过程</h3><p>进程调度和切换程序是操作系统内核程序。</p>
<p>现代操作系统各种，不能进行进程的调度和切换的情况有以下几种</p>
<ol>
<li>在处理中断的过程中。</li>
<li>进程在操作系统内核程序临界区中。</li>
<li>其他需要完全屏蔽中断的原子操作过程中。</li>
</ol>
<p>应该进行进程调度与切换的情况如下：</p>
<ol>
<li>发生引起调度条件且当前进程无法继续运行下去时，可以马航进行调度与切换。若操作系统只在这种情况下进行系统给调度，则是非剥夺调度。</li>
<li>中断处理结束或自陷处理结束后。剥夺方式的调度</li>
</ol>
<h3 id="2-2-3-进程调度方式"><a href="#2-2-3-进程调度方式" class="headerlink" title="2.2.3 进程调度方式"></a>2.2.3 进程调度方式</h3><ol>
<li>非剥夺调度方式，又称非抢占方式。</li>
<li>剥夺调度方式，又称抢占方式。</li>
</ol>
<h3 id="2-2-4-调度的基本准则"><a href="#2-2-4-调度的基本准则" class="headerlink" title="2.2.4 调度的基本准则"></a>2.2.4 调度的基本准则</h3><p>为了比较处理机调度算法的性能，人们提出了很多评价准则，下面介绍其中主要的几种：</p>
<ol>
<li>CPU利用率。尽可能使这一资源利用率最高。</li>
<li>系统吞吐量。 表示单位时间内CPU完成作业的数量。</li>
<li>周转时间。周转时间是指从作业提交到作业完成所需要的时间。</li>
<li>等待时间。</li>
<li>响应时间。</li>
</ol>
<h3 id="2-2-5-典型的调度算法"><a href="#2-2-5-典型的调度算法" class="headerlink" title="2.2.5 典型的调度算法"></a>2.2.5 典型的调度算法</h3><p>操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。</p>
<h4 id="1-先来先服务（FCFS）调度算法"><a href="#1-先来先服务（FCFS）调度算法" class="headerlink" title="1. 先来先服务（FCFS）调度算法"></a>1. 先来先服务（FCFS）调度算法</h4><p>特点：算法简单，效率低；对长作业比较有利，但对短作业不利；有利于CPU繁忙型作业，不利于I/O繁忙型作业。</p>
<h4 id="2-短作业优先-SJF-调度算法"><a href="#2-短作业优先-SJF-调度算法" class="headerlink" title="2. 短作业优先 (SJF) 调度算法"></a>2. 短作业优先 (SJF) 调度算法</h4><p>特点：平均等待时间，平均周转时间最少。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>
<h4 id="3-优先级调度算法"><a href="#3-优先级调度算法" class="headerlink" title="3. 优先级调度算法"></a>3. 优先级调度算法</h4><p>它即可用于作业调度，又可用于进程调度。</p>
<p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为如下两种：</p>
<ol>
<li>非剥夺式优先级调度算法。</li>
<li>剥夺式优先级调度算法。</li>
</ol>
<p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p>
<ol>
<li>静态优先级。</li>
<li>动态优先级。</li>
</ol>
<p>一般来说，进程优先级的设置可以参照以下原则：</p>
<ol>
<li>系统进程 &gt; 用户进程。 系统进程作为系统的管理者，理应拥有更高的优先级。</li>
<li>交互型进程 &gt; 非交互型进程（或前台进程 大于 后台进程）。</li>
<li>I/O 型进程 ＞ 计算型进程。</li>
</ol>
<h4 id="4-高响应比优先调度算法"><a href="#4-高响应比优先调度算法" class="headerlink" title="4. 高响应比优先调度算法"></a>4. 高响应比优先调度算法</h4><p>高响应比优先调度算法主要用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<h4 id="5-时间片轮转调度算法"><a href="#5-时间片轮转调度算法" class="headerlink" title="5. 时间片轮转调度算法"></a>5. 时间片轮转调度算法</h4><p>先到先得，只分配一个固定时间片</p>
<h4 id="6-多级反馈队列调度算法（融合了前几种算法的优点）"><a href="#6-多级反馈队列调度算法（融合了前几种算法的优点）" class="headerlink" title="6. 多级反馈队列调度算法（融合了前几种算法的优点）"></a>6. 多级反馈队列调度算法（融合了前几种算法的优点）</h4><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。</p>
<p>实现思想如下：</p>
<ol>
<li>设置多个就绪队列，并为各个队列赋予不同的优先级，第一级队列的优先级最高。</li>
<li>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程的运行时间片越小。</li>
<li>先把进程放在第一级末尾，时间片内未完成再放到第二级，以此类推…</li>
<li>仅当第一级队列为空，调度程序才调度第2级队列中的进程运行。</li>
</ol>
<p>优点：</p>
<p>终端型作业用户：短作业优先</p>
<p>短批处理作业用户：周转时间较短</p>
<p>长批处理作业用户：经过前面几个队列部分执行，不会长期得不到处理。</p>
<h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h2><h3 id="2-3-1-进程同步的基本概念"><a href="#2-3-1-进程同步的基本概念" class="headerlink" title="2.3.1 进程同步的基本概念"></a>2.3.1 进程同步的基本概念</h3><p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h4 id="1-临界资源"><a href="#1-临界资源" class="headerlink" title="1. 临界资源"></a>1. 临界资源</h4><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次都只能为一个进程所用，我们将一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源。</p>
<p>为了保证临界资源的正确使用，可把临界资源的访问分为4个部分：</p>
<ul>
<li>进入区，若能进入临界区，设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>临界区</li>
<li>退出区，将标志清除。</li>
<li>剩余区</li>
</ul>
<h4 id="2-同步"><a href="#2-同步" class="headerlink" title="2. 同步"></a>2. 同步</h4><p>同步也称为直接制约关系，是指为完成某种任务而建立的两个或者多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递消息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p>
<h4 id="3-互斥"><a href="#3-互斥" class="headerlink" title="3. 互斥"></a>3. 互斥</h4><p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问临界资源。</p>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<ol>
<li>空闲让进。</li>
<li>忙则等待</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
<h3 id="2-3-2-实现临界区互斥的基本方法"><a href="#2-3-2-实现临界区互斥的基本方法" class="headerlink" title="2.3.2 实现临界区互斥的基本方法"></a>2.3.2 实现临界区互斥的基本方法</h3><h4 id="1-软件实现方法"><a href="#1-软件实现方法" class="headerlink" title="1. 软件实现方法"></a>1. 软件实现方法</h4><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<ol>
<li><p>单标志法。</p>
</li>
<li><p>双标志法先检查。</p>
</li>
<li><p>双标志法后检查。</p>
</li>
<li><p>算法四：Peterson’s Algorithm。 为了防止两个进程为进入临界区而无限期等待，设置变量turn,每个进程在先设置自己的标志后再设置turn 标志。</p>
</li>
</ol>
<h4 id="2-硬件实现方法"><a href="#2-硬件实现方法" class="headerlink" title="2. 硬件实现方法"></a>2. 硬件实现方法</h4><p>通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p>
<p>（1）中断屏蔽方法</p>
<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区进行访问的最简方法是，禁止一切中断发生，或称之为屏蔽中断、关中断。</p>
<p>缺点：关中断是很方便的，但将关中断的权利交给用户则是很不明智，若一个进程关中断后不再开中断，则系统可能因此终止。</p>
<p>（2）硬件指令方法</p>
<p>TestAndSet指令。</p>
<h3 id="2-3-3-信号量"><a href="#2-3-3-信号量" class="headerlink" title="2.3.3 信号量"></a>2.3.3 信号量</h3><p>信号量机制是一种功能较强的机制，可用来解决互斥和同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为“P操作”和“V操作”。原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。</p>
<h4 id="1-整型信号量"><a href="#1-整型信号量" class="headerlink" title="1. 整型信号量"></a>1. 整型信号量</h4><h4 id="2-记录型信号量"><a href="#2-记录型信号量" class="headerlink" title="2. 记录型信号量"></a>2. 记录型信号量</h4><h4 id="3-利用信号量实现同步"><a href="#3-利用信号量实现同步" class="headerlink" title="3. 利用信号量实现同步"></a>3. 利用信号量实现同步</h4><h4 id="4-利用信号量实现进程互斥"><a href="#4-利用信号量实现进程互斥" class="headerlink" title="4. 利用信号量实现进程互斥"></a>4. 利用信号量实现进程互斥</h4><h4 id="5-利用信号量实现前驱关系"><a href="#5-利用信号量实现前驱关系" class="headerlink" title="5. 利用信号量实现前驱关系"></a>5. 利用信号量实现前驱关系</h4><h4 id="6-分析进程同步和互斥问题的方法步骤"><a href="#6-分析进程同步和互斥问题的方法步骤" class="headerlink" title="6. 分析进程同步和互斥问题的方法步骤"></a>6. 分析进程同步和互斥问题的方法步骤</h4><ol>
<li>关系分析</li>
<li>整理思路</li>
<li>设置信号量</li>
</ol>
<h3 id="2-3-4-管程"><a href="#2-3-4-管程" class="headerlink" title="2.3.4 管程"></a>2.3.4 管程</h3><h4 id="1-管程的定义"><a href="#1-管程的定义" class="headerlink" title="1.管程的定义"></a>1.管程的定义</h4><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>
<p>管程由四部分组成：</p>
<ul>
<li>管程的名称</li>
<li>局部于管程内部的共享结构数据说明。</li>
<li>对该数据结构进行操作的一组过程（或函数）</li>
<li>对局部于管程内部的共享数据设置初始值的语句。</li>
</ul>
<p>特点：</p>
<ol>
<li>管程把共享资源的操作封装起来。</li>
<li>每次仅允许一个进程进入管程，从而实现进程互斥。</li>
</ol>
<h4 id="2-条件变量"><a href="#2-条件变量" class="headerlink" title="2.条件变量"></a>2.条件变量</h4><p>当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不是放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为条件变量condition.</p>
<h4 id="2-3-5-经典同步问题"><a href="#2-3-5-经典同步问题" class="headerlink" title="2.3.5 经典同步问题"></a>2.3.5 经典同步问题</h4><h4 id="1-生产者-消费者问题"><a href="#1-生产者-消费者问题" class="headerlink" title="1. 生产者-消费者问题"></a>1. 生产者-消费者问题</h4><p>只是一个同步互斥问题的综合。</p>
<h4 id="2-读者-写者问题"><a href="#2-读者-写者问题" class="headerlink" title="2. 读者-写者问题"></a>2. 读者-写者问题</h4><p>要求：多个读者可以同时执行对文件读的操作，只允许一个写者写信息，写者完成操作之前不允许其他读者或写者工作，写者执行写操作，应当让所有读者和写者退出。</p>
<h4 id="3-哲学家进餐问题"><a href="#3-哲学家进餐问题" class="headerlink" title="3. 哲学家进餐问题"></a>3. 哲学家进餐问题</h4><h4 id="4-吸烟者问题"><a href="#4-吸烟者问题" class="headerlink" title="4. 吸烟者问题"></a>4. 吸烟者问题</h4><h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4  死锁"></a>2.4  死锁</h2><h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><h4 id="1-死锁的定义"><a href="#1-死锁的定义" class="headerlink" title="1. 死锁的定义"></a>1. 死锁的定义</h4><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。</p>
<p>然而导致了死锁问题的产生。</p>
<p>所谓死锁是指，多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进。</p>
<h4 id="2-死锁产生的原因"><a href="#2-死锁产生的原因" class="headerlink" title="2. 死锁产生的原因"></a>2. 死锁产生的原因</h4><ol>
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
<li>死锁产生的必要条件<ul>
<li>互斥条件</li>
<li>不剥夺条件</li>
<li>请求并保持条件</li>
<li>循环等待条件</li>
</ul>
</li>
</ol>
<h3 id="2-4-2-死锁的处理策略"><a href="#2-4-2-死锁的处理策略" class="headerlink" title="2.4.2 死锁的处理策略"></a>2.4.2 死锁的处理策略</h3><p>破坏四个死锁的必要条件。</p>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p>[考纲内容]</p>
<p>（一）内存管理概念</p>
<p>内存管理的概念；交换与覆盖；连续分配管理方式</p>
<p>（二）虚拟内存管理</p>
<p>虚拟内存的概念；请求分页管理方式；页面置换算法</p>
<p>本章围绕分页机制展开：通过分页管理方式再物理内存大小的基础上提高内存的利用率，再进一步引入请求分页管理方式，实现虚拟内存，使内存脱离物理大小的限制，从而提高处理器的利用率。</p>
<h2 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h2><h3 id="3-1-1-内存管理的基本管理和要求"><a href="#3-1-1-内存管理的基本管理和要求" class="headerlink" title="3.1.1 内存管理的基本管理和要求"></a>3.1.1 内存管理的基本管理和要求</h3><p>内存管理是操作系统设计中最重要和最复杂的内容复之一。</p>
<p>内存管理的功能有：</p>
<ul>
<li>内存空间的分配和回收。由操作系统完成主存储器空间的分配和管理，使程序员拜托存储分配的麻烦，提高编程效率。</li>
<li>地址转换。在多道程序环境下，程序中的逻辑地址和内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换为相应的物理地址。</li>
<li>内存空间的扩充。利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li>存储保护。保证各道作业在各自的存储空间内运行，互补干扰。</li>
</ul>
<h4 id="1-程序装入和链接。"><a href="#1-程序装入和链接。" class="headerlink" title="1. 程序装入和链接。"></a>1. 程序装入和链接。</h4><p>将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<ul>
<li>编译</li>
<li>链接</li>
<li>装入</li>
</ul>
<p>程序链接有以下三种方式。</p>
<ul>
<li>静态链接。在程序运行之前，先将各目标模块以及他们所需的库函数连接成一个完整的可执行程序，以后不再拆开。</li>
<li>装入时动态链接。将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。</li>
<li>运行时动态链接。</li>
</ul>
<p>内存的装入模块在装入内存时，同样有三种方式：</p>
<ol>
<li>绝对装入。只适用于单道程序环境。</li>
<li>可重定位装入。</li>
<li>动态运行时装入，也称动态重定位。</li>
</ol>
<h4 id="2-逻辑地址空间与物理地址空间"><a href="#2-逻辑地址空间与物理地址空间" class="headerlink" title="2. 逻辑地址空间与物理地址空间"></a>2. 逻辑地址空间与物理地址空间</h4><p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换为物理地址，这个过程叫做地址重定位。</p>
<h4 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3. 内存保护"></a>3. 内存保护</h4><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p>
<ol>
<li>在CPU设置一对上、下限寄存器。</li>
<li>采用重定位寄存器和界地址寄存器来实现保护。</li>
</ol>
<h3 id="3-1-2-覆盖与交换"><a href="#3-1-2-覆盖与交换" class="headerlink" title="3.1.2 覆盖与交换"></a>3.1.2 覆盖与交换</h3><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种办法。</p>
<ol>
<li><p>覆盖</p>
<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。</p>
<p>特点：打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当时运行程序的代码量大于主存时仍不能运行，此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。</p>
</li>
<li><p>交换</p>
<p>交换的基本思想是，把处于等待状态的程序从内存移到辅存，把内存空间腾出来，这一过程又称为换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。</p>
</li>
</ol>
<h3 id="3-1-3-连续分配管理方式"><a href="#3-1-3-连续分配管理方式" class="headerlink" title="3.1.3 连续分配管理方式"></a>3.1.3 连续分配管理方式</h3><p>连续分配管理方式是指为一个用户程序分配一个连续的内存空间，比如某用户需要1GB的内存空间，连续分配方式就在内存空间为用户分配一块连续的1GB空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。</p>
<h4 id="1-单一连续分配"><a href="#1-单一连续分配" class="headerlink" title="1. 单一连续分配"></a>1. 单一连续分配</h4><p>优点：简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p>
<h4 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2. 固定分区分配"></a>2. 固定分区分配</h4><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。</p>
<p>方法：</p>
<ul>
<li><p>分区大小相等</p>
</li>
<li><p>分区大小不等</p>
<p>这种分区方式存在两个问题：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间；二是主存利用率低，当程序小于固定分区大小时，也占用一个完整的内存分区空间，这样分区内部就存在空间浪费，这种现象称为内部碎片。</p>
<p>固定分区可用于多道程序设计的最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p>
</li>
</ul>
<h4 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3. 动态分区分配"></a>3. 动态分区分配</h4><p>动态分区分配又称可变分区分配，是一种动态划分内存的区分方法。这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好合适进程的需要。因此，系统中的分区的大小和数目是可变的。</p>
<p>动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片，内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片。克服外部碎片需要通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。</p>
<p>但这需要动态重定位寄存器的支持，且相对费时。</p>
<p>在进程装入活换入主存时，若内存中又多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。</p>
<ol>
<li>首次适应算法。顺序查到第一个满足的</li>
<li>最佳适应算法。按容量递增排序，找到第一个满足的。</li>
<li>最坏适应算法。按容量递减排序，找到第一个满足的。</li>
<li>邻近适应算法。又称循环首次适应算法。分配内存时从上次查找结束的位置开始继续查找。</li>
</ol>
<h3 id="3-1-4-非连续分配管理方式"><a href="#3-1-4-非连续分配管理方式" class="headerlink" title="3.1.4 非连续分配管理方式"></a>3.1.4 非连续分配管理方式</h3><p>非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。</p>
<h4 id="1-分页存储管理方式"><a href="#1-分页存储管理方式" class="headerlink" title="1. 分页存储管理方式"></a>1. 分页存储管理方式</h4><p>分页存储管理方式中，根据运行作业时是否要把作业的所有页面都撞入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式。</p>
<ol>
<li><p>分页存储的基本概念</p>
<p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p>
<p>分页存储的基本概念：</p>
<ul>
<li>页面和页面大小。进程中的块称为页，内存中的块称为页框。外村中直接称为块。页面大小应当适中。</li>
<li>地址结构</li>
<li>页表。为了方便内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，它记录页面正在内存中对应的物理块号，页表一般存放在内存中。</li>
</ul>
</li>
<li><p>基本地址变换结构。</p>
<p>页表项的作用是找到该页在内存中的位置。</p>
<p>分页管理方式存在的两个主要问题：</p>
<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够块，否则访存速度会下降</li>
<li>每个进程引入页表，用于内存映射机制，页表不能太大，否则内存利用率会降低。</li>
</ul>
</li>
<li><p>具有快表的地址变换机构</p>
</li>
<li><p>两级页表</p>
</li>
</ol>
<h4 id="2-基本分段存储管理方式"><a href="#2-基本分段存储管理方式" class="headerlink" title="2. 基本分段存储管理方式"></a>2. 基本分段存储管理方式</h4><p>分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长以及动态链接等多方面的需要。</p>
<ul>
<li>分段</li>
<li>段表</li>
<li>地址变换机构</li>
<li>段的共享和保护</li>
</ul>
<h4 id="3-段页式管理方式"><a href="#3-段页式管理方式" class="headerlink" title="3. 段页式管理方式"></a>3. 段页式管理方式</h4><p>页式存储管理能有效的提高内存利用率，而分段存储管理能反应程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。</p>
<p>在一个进程中，段表只有一个，而页表可能有多个。</p>
<p>段页式管理的地址空间是二维的。</p>
<h2 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h2><h3 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h3><h4 id="1-传统存储管理方式的特征"><a href="#1-传统存储管理方式的特征" class="headerlink" title="1. 传统存储管理方式的特征"></a>1. 传统存储管理方式的特征</h4><ul>
<li><p>一次性</p>
<p>作业必须一次性全部装入内存后，才能开始运行。</p>
</li>
<li><p>驻留性</p>
<p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出。</p>
</li>
</ul>
<h4 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h4><blockquote>
<p>Bill Joy说过：”在研究所时，我经常开玩笑地说高速缓存是计算机科学中唯一重要的思想。事实上，高速缓存技术确实极大地影响了计算机系统的设计。”块表、页高速缓存及虚拟内存技术从广义上讲，都属于高速缓存技术。这个技术所依赖的原理就是局部性原理。</p>
</blockquote>
<p>局部性原理表现在两个方面。</p>
<ol>
<li>时间局部性。</li>
<li>空间局部性。</li>
</ol>
<p>时间局部性通过将近来使用的指令和数据保存到高速缓冲存储器中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存。</p>
<h4 id="3-虚拟存储器的定义和特征"><a href="#3-虚拟存储器的定义和特征" class="headerlink" title="3. 虚拟存储器的定义和特征"></a>3. 虚拟存储器的定义和特征</h4><p>虚拟存储器主要有三个主要特征：</p>
<ol>
<li><p>多次性。多次性是指无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行。</p>
</li>
<li><p>对换性。允许在作业的运行过程中，进行换进和换出。</p>
</li>
<li><p>虚拟性。虚拟性是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。</p>
</li>
</ol>
<h4 id="4-虚拟内存技术的实现"><a href="#4-虚拟内存技术的实现" class="headerlink" title="4. 虚拟内存技术的实现"></a>4. 虚拟内存技术的实现</h4><ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<p>不管哪种方式，都需要一定的硬件支持。一般需要的支持有以下几个方面</p>
<ul>
<li>一定容量的内存和外存</li>
<li>页表机制（或段表机制），作为主要的数据结构</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>
</ul>
<h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><h4 id="1-页表机制"><a href="#1-页表机制" class="headerlink" title="1. 页表机制"></a>1. 页表机制</h4><p>请求分页系统的页表项：</p>
<p>页号、物理块号、状态位、访问字段、修改位、外存地址</p>
<h4 id="2-缺页中断机构"><a href="#2-缺页中断机构" class="headerlink" title="2. 缺页中断机构"></a>2. 缺页中断机构</h4><h4 id="3-地址变换机构"><a href="#3-地址变换机构" class="headerlink" title="3. 地址变换机构"></a>3. 地址变换机构</h4><h3 id="3-2-3-页面置换算法（决定应该换入哪页、换出哪页）"><a href="#3-2-3-页面置换算法（决定应该换入哪页、换出哪页）" class="headerlink" title="3.2.3 页面置换算法（决定应该换入哪页、换出哪页）"></a>3.2.3 页面置换算法（决定应该换入哪页、换出哪页）</h3><p>常见的置换算法有4种。</p>
<h4 id="1-最佳（OPT）置换算法"><a href="#1-最佳（OPT）置换算法" class="headerlink" title="1. 最佳（OPT）置换算法"></a>1. 最佳（OPT）置换算法</h4><p>最佳置换算法选择的是被爆胎页面是以后永不使用的页面，或是在最长时间内不再被访问的页面，以便保证获得最低的缺页率。</p>
<h4 id="2-先进先出（FIFO）页面置换算法"><a href="#2-先进先出（FIFO）页面置换算法" class="headerlink" title="2. 先进先出（FIFO）页面置换算法"></a>2. 先进先出（FIFO）页面置换算法</h4><p>优先淘汰最早进入内存的页面，即在内存种驻留时间最久的页面。</p>
<p>FIFO算法还会产生所分配的物理块数增大而页故障数不减反增的异常现象。</p>
<h4 id="3-最近最久未使用（LRU）置换算法"><a href="#3-最近最久未使用（LRU）置换算法" class="headerlink" title="3. 最近最久未使用（LRU）置换算法"></a>3. 最近最久未使用（LRU）置换算法</h4><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来也可能不会被访问。</p>
<h4 id="4-时钟置换算法"><a href="#4-时钟置换算法" class="headerlink" title="4. 时钟置换算法"></a>4. 时钟置换算法</h4><p>LRU算法的性能接近于OPT算法，但实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。因此，操作系统的设计者尝试了很多的算法，试图用比较小的开销接近LRU算法的性能，这类算法都是CLOCK算法的变体。因为算法要循环扫描缓冲区，像时钟的指针一样转动，所以称为CLOCK算法。</p>
<h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h3><h4 id="1-驻留集大小"><a href="#1-驻留集大小" class="headerlink" title="1. 驻留集大小"></a>1. 驻留集大小</h4><p>对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的物理页框的集合就是这个进程的驻留集。需要考虑以下几点：</p>
<ol>
<li>分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。</li>
<li>若一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然相对较高。</li>
<li>若页数过多，则由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li>
</ol>
<p>基于这些因素，先到操作系统通常采用三种策略：</p>
<ol>
<li>固定分配局部置换。</li>
<li>可变分配全局置换。</li>
<li>可变分配局部置换。</li>
</ol>
<h4 id="2-调入页面的时机"><a href="#2-调入页面的时机" class="headerlink" title="2. 调入页面的时机"></a>2. 调入页面的时机</h4><ol>
<li>预调页策略。</li>
<li>请求调页策略。</li>
</ol>
<h4 id="3-从何处调入页面"><a href="#3-从何处调入页面" class="headerlink" title="3. 从何处调入页面"></a>3. 从何处调入页面</h4><ul>
<li>系统拥有足够的对换区空间。</li>
<li>系统缺少足够的对换区空间。</li>
<li>UNIX方式。</li>
</ul>
<h3 id="3-2-5-抖动"><a href="#3-2-5-抖动" class="headerlink" title="3.2.5 抖动"></a>3.2.5 抖动</h3><p>在页面置换过程中，一种糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换入主存，这种频繁的页面调度行为称为抖动或者颠簸。若一个进程在换页上用的时间多于执行时间，则这个进程就在颠簸。</p>
<h3 id="3-2-6-工作集"><a href="#3-2-6-工作集" class="headerlink" title="3.2.6 工作集"></a>3.2.6 工作集</h3><p>工作集是指在某段时间间隔内，进程要访问的页面集合。基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集W可由时间t和工作集窗口来决定。</p>
<h3 id="3-2-7-地址翻译"><a href="#3-2-7-地址翻译" class="headerlink" title="3.2.7 地址翻译"></a>3.2.7 地址翻译</h3>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci='bbbcedd212fd8db72b81'
        data-cs='54e10030c2e765a96c0649f988acef2bf6a400f9'
        data-r='comment'
        data-o='Ardcy'
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">计算机操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1.1 进程的概念和特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">1. 进程的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">2. 进程的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E5%8C%96"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.1.2 进程的状态与转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.0.3.</span> <span class="toc-text">2.1.3 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">1. 进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">2. 进程的终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">3. 进程的阻塞和唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.0.3.4.</span> <span class="toc-text">4. 进程切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">2.0.4.</span> <span class="toc-text">2.1.4 进程的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.0.5.</span> <span class="toc-text">2.1.5 进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">1. 共享存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">2. 消息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">3. 管道通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.6.</span> <span class="toc-text">2.1.6 线程概念和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">1. 线程的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">2. 线程与进程的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.6.3.</span> <span class="toc-text">3. 线程的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.6.4.</span> <span class="toc-text">4. 线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.6.5.</span> <span class="toc-text">5. 多线程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">2.2 处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.2.1 调度的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1. 调度的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2. 调度的层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">3. 三级调度之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%8C%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.2.2 调度的时机，切换与过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.2.3 进程调度方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.2.4 调度的基本准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.2.5 典型的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">1. 先来先服务（FCFS）调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">2. 短作业优先 (SJF) 调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">3. 优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">4. 高响应比优先调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">5. 时间片轮转调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%9E%8D%E5%90%88%E4%BA%86%E5%89%8D%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%89"><span class="toc-number">2.1.5.6.</span> <span class="toc-text">6. 多级反馈队列调度算法（融合了前几种算法的优点）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.3 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.3.1 进程同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1. 临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2. 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%92%E6%96%A5"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">3. 互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.3.2 实现临界区互斥的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1. 软件实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2. 硬件实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3.3 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">1. 整型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">2. 记录型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">3. 利用信号量实现同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">4. 利用信号量实现进程互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">5. 利用信号量实现前驱关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.3.6.</span> <span class="toc-text">6. 分析进程同步和互斥问题的方法步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.3.4 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">1.管程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">2.3.5 经典同步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">1. 生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">2. 读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">3. 哲学家进餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.7.</span> <span class="toc-text">4. 吸烟者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%AD%BB%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">2.4  死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.4.1 死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">1. 死锁的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2. 死锁产生的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.4.2 死锁的处理策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%A1%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 内存管理的基本管理和要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5%E3%80%82"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1. 程序装入和链接。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2. 逻辑地址空间与物理地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">3. 内存保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 覆盖与交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1. 单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">2. 固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">3. 动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4 非连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">1. 分页存储管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">2. 基本分段存储管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">3. 段页式管理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">1. 传统存储管理方式的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2. 局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">3. 虚拟存储器的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">4. 虚拟内存技术的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1. 页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2. 缺页中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3. 地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88%E5%86%B3%E5%AE%9A%E5%BA%94%E8%AF%A5%E6%8D%A2%E5%85%A5%E5%93%AA%E9%A1%B5%E3%80%81%E6%8D%A2%E5%87%BA%E5%93%AA%E9%A1%B5%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 页面置换算法（决定应该换入哪页、换出哪页）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E4%BD%B3%EF%BC%88OPT%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. 最佳（OPT）置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 先进先出（FIFO）页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3. 最近最久未使用（LRU）置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">4. 时钟置换算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A9%BB%E7%95%99%E9%9B%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">1. 驻留集大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">2. 调入页面的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">3. 从何处调入页面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E6%8A%96%E5%8A%A8"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5 抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6 工作集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">3.2.7.</span> <span class="toc-text">3.2.7 地址翻译</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
